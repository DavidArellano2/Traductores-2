{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green128\blue0;\red0\green0\blue0;\red255\green0\blue0;\red128\green0\blue128;\red0\green120\blue215;\red0\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title P1v4.rtf}}

\deflang1033\pard\plain\f0\fs26 \cf0 #include <iostream>
\par #include <string>
\par 
\par \cf1\b using\b0  \b namespace\b0  std\cf2\b ;
\par 
\par \cf1 class\b0  Token
\par \cf2\b \{
\par \cf1 public\cf2 :
\par \b0\cf1     Token\cf2\b (\cf1 char\b0  type\cf2\b ,\b0\cf1  \b int\b0  val \cf2\b =\b0\cf1  \cf3 0\cf2\b )\b0\cf1  \cf2\b :\b0\cf1  tipo\cf2\b (\b0\cf1 type\cf2\b ),\b0\cf1  valor\cf2\b (\b0\cf1 val\cf2\b )\b0\cf1  \cf2\b \{\}
\par 
\par \b0\cf1     \b char\b0  getType\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b return\b0  tipo\cf2\b ;
\par \b0\cf1     \cf2\b \}
\par 
\par \b0\cf1     \b int\b0  getVal\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b return\b0  valor\cf2\b ;
\par \b0\cf1     \cf2\b \}
\par 
\par \cf1 private\cf2 :
\par \b0\cf1     \b char\b0  tipo\cf2\b ;
\par \b0\cf1     \b int\b0  valor\cf2\b ;
\par \};
\par 
\par \cf1 class\b0  Lexer
\par \cf2\b \{
\par \cf1 public\cf2 :
\par \b0\cf1     Lexer\cf2\b (\b0\cf1 string input\cf2\b )\b0\cf1  \cf2\b :\b0\cf1  entrada\cf2\b (\b0\cf1 input\cf2\b ),\b0\cf1  posicion\cf2\b (\b0\cf3 0\cf2\b )\b0\cf1  \cf2\b \{\}
\par 
\par \b0\cf1     Token getNextToken\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b char\b0  currentChar \cf2\b =\b0\cf1  getCurrentChar\cf2\b ();
\par 
\par \b0\cf1         \b if\b0  \cf2\b (\b0\cf1 isdigit\cf2\b (\b0\cf1 currentChar\cf2\b ))
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             \b int\b0  value \cf2\b =\b0\cf1  currentChar \cf2\b -\b0\cf1  '0'\cf2\b ;
\par \b0\cf1             avanza\cf2\b ();
\par \b0\cf1             \b while\b0  \cf2\b (\b0\cf1 isdigit\cf2\b (\b0\cf1 getCurrentChar\cf2\b ()))
\par \b0\cf1             \cf2\b \{
\par \b0\cf1                 value \cf2\b =\b0\cf1  value \cf2\b *\b0\cf1  \cf3 10\cf1  \cf2\b +\b0\cf1  \cf2\b (\b0\cf1 getCurrentChar\cf2\b ()\b0\cf1  \cf2\b -\b0\cf1  '0'\cf2\b );
\par \b0\cf1                 avanza\cf2\b ();
\par \b0\cf1             \cf2\b \}
\par \b0\cf1             \b return\b0  Token\cf2\b (\b0\cf1 'n'\cf2\b ,\b0\cf1  value\cf2\b );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \cf4\i // Si el caracter actual es un operador o parentesis, devolver el token correspondiente
\par \i0\cf1         \b else\b0  \b if\b0  \cf2\b (\b0\cf1 currentChar \cf2\b ==\b0\cf1  '+'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             avanza\cf2\b ();
\par \b0\cf1             \b return\b0  Token\cf2\b (\b0\cf1 '+'\cf2\b );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else\b0  \b if\b0  \cf2\b (\b0\cf1 currentChar \cf2\b ==\b0\cf1  '-'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             avanza\cf2\b ();
\par \b0\cf1             \b return\b0  Token\cf2\b (\b0\cf1 '-'\cf2\b );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else\b0  \b if\b0  \cf2\b (\b0\cf1 currentChar \cf2\b ==\b0\cf1  '*'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             avanza\cf2\b ();
\par \b0\cf1             \b return\b0  Token\cf2\b (\b0\cf1 '*'\cf2\b );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else\b0  \b if\b0  \cf2\b (\b0\cf1 currentChar \cf2\b ==\b0\cf1  '/'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             avanza\cf2\b ();
\par \b0\cf1             \b return\b0  Token\cf2\b (\b0\cf1 '/'\cf2\b );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else\b0  \b if\b0  \cf2\b (\b0\cf1 currentChar \cf2\b ==\b0\cf1  '('\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             avanza\cf2\b ();
\par \b0\cf1             \b return\b0  Token\cf2\b (\b0\cf1 '('\cf2\b );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else\b0  \b if\b0  \cf2\b (\b0\cf1 currentChar \cf2\b ==\b0\cf1  ')'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             avanza\cf2\b ();
\par \b0\cf1             \b return\b0  Token\cf2\b (\b0\cf1 ')'\cf2\b );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \cf4\i // Si no es ningun simbolo valido, lanzar una excepcion
\par \i0\cf1         \b else
\par \b0         \cf2\b \{
\par \b0\cf1             \b throw\b0  runtime_error\cf2\b (\cf5 "Error de sintaxis: simbolo invalido"\cf2 );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1     \cf2\b \}
\par 
\par \cf1 private\cf2 :
\par \b0\cf1     string entrada\cf2\b ;
\par \b0\cf1     \b int\b0  posicion\cf2\b ;
\par \b0\cf1     \b char\b0  getCurrentChar\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b if\b0  \cf2\b (\b0\cf1 posicion \cf2\b >=\b0\cf1  entrada\cf2\b .\b0\cf1 length\cf2\b ())
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             \b return\b0  'x'\cf2\b ;
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else
\par \b0         \cf2\b \{
\par \b0\cf1             \b return\b0  entrada\cf2\b [\b0\cf1 posicion\cf2\b ];
\par \b0\cf1         \cf2\b \}
\par \b0\cf1     \cf2\b \}
\par \b0\cf1     \b void\b0  avanza\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         posicion\cf2\b ++;
\par \b0\cf1     \cf2\b \}
\par \};
\par 
\par \cf1 class\b0  Parser
\par \cf2\b \{
\par \cf1 public\cf2 :
\par \b0\cf1     Parser\cf2\b (\b0\cf1 Lexer \cf2\b &\b0\cf1 lexer\cf2\b )
\par \b0\cf1         \cf2\b :\b0\cf1  lexer_\cf2\b (\b0\cf1 lexer\cf2\b ),\b0\cf1  currentToken_\cf2\b (\b0\cf1 lexer\cf2\b .\b0\cf1 getNextToken\cf2\b ())
\par \b0\cf1     \cf2\b \{
\par \b0\cf1     \cf2\b \}
\par 
\par \b0\cf1     \b int\b0  expresion\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b int\b0  result \cf2\b =\b0\cf1  termino\cf2\b ();
\par 
\par \b0\cf1         \b while\b0  \cf2\b (\b0\cf1 currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  '+' \cf2\b ||\b0\cf1  currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  '-'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             \b if\b0  \cf2\b (\b0\cf1 currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  '+'\cf2\b )
\par \b0\cf1             \cf2\b \{
\par \b0\cf1                 consume\cf2\b (\b0\cf1 '+'\cf2\b );
\par \b0\cf1                 result \cf2\b +=\b0\cf1  termino\cf2\b ();
\par \b0\cf1             \cf2\b \}
\par \b0\cf1             \b else
\par \b0             \cf2\b \{
\par \b0\cf1                 consume\cf2\b (\b0\cf1 '-'\cf2\b );
\par \b0\cf1                 result \cf2\b -=\b0\cf1  termino\cf2\b ();
\par \b0\cf1             \cf2\b \}
\par \b0\cf1         \cf2\b \}
\par 
\par \b0\cf1         \b return\b0  result\cf2\b ;
\par \b0\cf1     \cf2\b \}
\par 
\par \b0\cf1     \b int\b0  termino\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b int\b0  result \cf2\b =\b0\cf1  factor\cf2\b ();
\par 
\par \b0\cf1         \b while\b0  \cf2\b (\b0\cf1 currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  '*' \cf2\b ||\b0\cf1  currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  '/'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             \b if\b0  \cf2\b (\b0\cf1 currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  '*'\cf2\b )
\par \b0\cf1             \cf2\b \{
\par \b0\cf1                 consume\cf2\b (\b0\cf1 '*'\cf2\b );
\par \b0\cf1                 result \cf2\b *=\b0\cf1  factor\cf2\b ();
\par \b0\cf1             \cf2\b \}
\par \b0\cf1             \b else
\par \b0             \cf2\b \{
\par \b0\cf1                 consume\cf2\b (\b0\cf1 '/'\cf2\b );
\par \b0\cf1                 result \cf2\b /=\b0\cf1  factor\cf2\b ();
\par \b0\cf1             \cf2\b \}
\par \b0\cf1         \cf2\b \}
\par 
\par \b0\cf1         \b return\b0  result\cf2\b ;
\par \b0\cf1     \cf2\b \}
\par 
\par \b0\cf1     \b int\b0  factor\cf2\b ()
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b if\b0  \cf2\b (\b0\cf1 currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  '('\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             consume\cf2\b (\b0\cf1 '('\cf2\b );
\par \b0\cf1             \b int\b0  result \cf2\b =\b0\cf1  expresion\cf2\b ();
\par \b0\cf1             consume\cf2\b (\b0\cf1 ')'\cf2\b );
\par \b0\cf1             \b return\b0  result\cf2\b ;
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else\b0  \b if\b0  \cf2\b (\b0\cf1 currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  'n'\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             \b int\b0  result \cf2\b =\b0\cf1  currentToken_\cf2\b .\b0\cf1 getVal\cf2\b ();
\par \b0\cf1             consume\cf2\b (\b0\cf1 'n'\cf2\b );
\par \b0\cf1             \b return\b0  result\cf2\b ;
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else
\par \b0         \cf2\b \{
\par \b0\cf1             \b throw\b0  runtime_error\cf2\b (\cf5 "Factor invalido"\cf2 );
\par \b0\cf1         \cf2\b \}
\par \b0\cf1     \cf2\b \}
\par 
\par \cf1 private\cf2 :
\par \b0\cf1     \b void\b0  consume\cf2\b (\cf1 char\b0  tipo\cf2\b )
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b if\b0  \cf2\b (\b0\cf1 currentToken_\cf2\b .\b0\cf1 getType\cf2\b ()\b0\cf1  \cf2\b ==\b0\cf1  tipo\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             currentToken_ \cf2\b =\b0\cf1  lexer_\cf2\b .\b0\cf1 getNextToken\cf2\b ();
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else
\par \b0         \cf2\b \{
\par \b0\cf1             \b throw\b0  runtime_error\cf2\b (\cf5 "Token inesperado: "\b0\cf1  \cf2\b +\b0\cf1  currentToken_\cf2\b .\b0\cf1 getVal\cf2\b ());
\par \b0\cf1         \cf2\b \}
\par \b0\cf1     \cf2\b \}
\par \b0\cf1     Lexer lexer_\cf2\b ;
\par \b0\cf1     Token currentToken_\cf2\b ;
\par \};
\par 
\par \cf1 int\b0  main\cf2\b ()
\par \{
\par \b0\cf1     string input\cf2\b ;
\par \b0\cf1     cout \cf2\b <<\b0\cf1  \cf5\b "Ingrese una expresion aritmetica: "\cf2 ;
\par \b0\cf1     getline\cf2\b (\b0\cf1 cin\cf2\b ,\b0\cf1  input\cf2\b );
\par 
\par \b0\cf1     Lexer lexer\cf2\b (\b0\cf1 input\cf2\b );
\par \b0\cf1     Parser parser\cf2\b (\b0\cf1 lexer\cf2\b );
\par 
\par \b0\cf1     \b try
\par \b0     \cf2\b \{
\par \b0\cf1         \b int\b0  resultado \cf2\b =\b0\cf1  parser\cf2\b .\b0\cf1 expresion\cf2\b ();
\par \b0\cf1         cout \cf2\b <<\b0\cf1  \cf5\b "El resultado es: "\b0\cf1  \cf2\b <<\b0\cf1  resultado \cf2\b <<\b0\cf1  endl\cf2\b ;
\par \b0\cf1     \cf2\b \}
\par \b0\cf1     \b catch\b0  \cf2\b (\cf1 const\b0  exception \cf2\b &\b0\cf1 ex\cf2\b )
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         cerr \cf2\b <<\b0\cf1  \cf5\b "Error: "\b0\cf1  \cf2\b <<\b0\cf1  ex\cf2\b .\b0\cf1 what\cf2\b ()\b0\cf1  \cf2\b <<\b0\cf1  endl\cf2\b ;
\par \b0\cf1     \cf2\b \}
\par \b0\cf1     \b return\b0  \cf3 0\cf2\b ;
\par \}
\par }